// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/jmoiron/sqlx"
	"github.com/kngnkg/tunetrail/restapi/model"
	"github.com/kngnkg/tunetrail/restapi/store"
	"sync"
)

// Ensure, that HealthRepositoryMock does implement HealthRepository.
// If this is not the case, regenerate this file with moq.
var _ HealthRepository = &HealthRepositoryMock{}

// HealthRepositoryMock is a mock implementation of HealthRepository.
//
//	func TestSomethingThatUsesHealthRepository(t *testing.T) {
//
//		// make and configure a mocked HealthRepository
//		mockedHealthRepository := &HealthRepositoryMock{
//			PingFunc: func(ctx context.Context, db store.Queryer) error {
//				panic("mock out the Ping method")
//			},
//		}
//
//		// use mockedHealthRepository in code that requires HealthRepository
//		// and then make assertions.
//
//	}
type HealthRepositoryMock struct {
	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context, db store.Queryer) error

	// calls tracks calls to the methods.
	calls struct {
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
		}
	}
	lockPing sync.RWMutex
}

// Ping calls PingFunc.
func (mock *HealthRepositoryMock) Ping(ctx context.Context, db store.Queryer) error {
	if mock.PingFunc == nil {
		panic("HealthRepositoryMock.PingFunc: method is nil but HealthRepository.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Queryer
	}{
		Ctx: ctx,
		Db:  db,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx, db)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedHealthRepository.PingCalls())
func (mock *HealthRepositoryMock) PingCalls() []struct {
	Ctx context.Context
	Db  store.Queryer
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Queryer
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// Ensure, that UserRepositoryMock does implement UserRepository.
// If this is not the case, regenerate this file with moq.
var _ UserRepository = &UserRepositoryMock{}

// UserRepositoryMock is a mock implementation of UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked UserRepository
//		mockedUserRepository := &UserRepositoryMock{
//			AddFollowFunc: func(ctx context.Context, db store.Execer, userId model.UserID, follweeUserId model.UserID) error {
//				panic("mock out the AddFollow method")
//			},
//			DeleteFollowFunc: func(ctx context.Context, db store.Execer, userId model.UserID, follweeUserId model.UserID) error {
//				panic("mock out the DeleteFollow method")
//			},
//			DeleteUserByUserNameFunc: func(ctx context.Context, db store.Execer, userName string) error {
//				panic("mock out the DeleteUserByUserName method")
//			},
//			GetFolloweesByUserIdFunc: func(ctx context.Context, db store.Queryer, signedInUserId model.UserID) ([]*model.User, error) {
//				panic("mock out the GetFolloweesByUserId method")
//			},
//			GetUserByUserIdFunc: func(ctx context.Context, db store.Queryer, id model.UserID) (*model.User, error) {
//				panic("mock out the GetUserByUserId method")
//			},
//			GetUserByUserNameFunc: func(ctx context.Context, db store.Queryer, userName string) (*model.User, error) {
//				panic("mock out the GetUserByUserName method")
//			},
//			GetUserByUserNameWithFollowInfoFunc: func(ctx context.Context, db store.Queryer, userName string, signedInUserId model.UserID) (*model.User, error) {
//				panic("mock out the GetUserByUserNameWithFollowInfo method")
//			},
//			RegisterUserFunc: func(ctx context.Context, db store.Execer, u *model.User) error {
//				panic("mock out the RegisterUser method")
//			},
//			UpdateUserFunc: func(ctx context.Context, db store.Execer, u *model.User) error {
//				panic("mock out the UpdateUser method")
//			},
//			UserExistsByUserNameFunc: func(ctx context.Context, db store.Queryer, userName string) (bool, error) {
//				panic("mock out the UserExistsByUserName method")
//			},
//			WithTransactionFunc: func(ctx context.Context, db store.Beginner, f func(tx *sqlx.Tx) error) error {
//				panic("mock out the WithTransaction method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires UserRepository
//		// and then make assertions.
//
//	}
type UserRepositoryMock struct {
	// AddFollowFunc mocks the AddFollow method.
	AddFollowFunc func(ctx context.Context, db store.Execer, userId model.UserID, follweeUserId model.UserID) error

	// DeleteFollowFunc mocks the DeleteFollow method.
	DeleteFollowFunc func(ctx context.Context, db store.Execer, userId model.UserID, follweeUserId model.UserID) error

	// DeleteUserByUserNameFunc mocks the DeleteUserByUserName method.
	DeleteUserByUserNameFunc func(ctx context.Context, db store.Execer, userName string) error

	// GetFolloweesByUserIdFunc mocks the GetFolloweesByUserId method.
	GetFolloweesByUserIdFunc func(ctx context.Context, db store.Queryer, signedInUserId model.UserID) ([]*model.User, error)

	// GetUserByUserIdFunc mocks the GetUserByUserId method.
	GetUserByUserIdFunc func(ctx context.Context, db store.Queryer, id model.UserID) (*model.User, error)

	// GetUserByUserNameFunc mocks the GetUserByUserName method.
	GetUserByUserNameFunc func(ctx context.Context, db store.Queryer, userName string) (*model.User, error)

	// GetUserByUserNameWithFollowInfoFunc mocks the GetUserByUserNameWithFollowInfo method.
	GetUserByUserNameWithFollowInfoFunc func(ctx context.Context, db store.Queryer, userName string, signedInUserId model.UserID) (*model.User, error)

	// RegisterUserFunc mocks the RegisterUser method.
	RegisterUserFunc func(ctx context.Context, db store.Execer, u *model.User) error

	// UpdateUserFunc mocks the UpdateUser method.
	UpdateUserFunc func(ctx context.Context, db store.Execer, u *model.User) error

	// UserExistsByUserNameFunc mocks the UserExistsByUserName method.
	UserExistsByUserNameFunc func(ctx context.Context, db store.Queryer, userName string) (bool, error)

	// WithTransactionFunc mocks the WithTransaction method.
	WithTransactionFunc func(ctx context.Context, db store.Beginner, f func(tx *sqlx.Tx) error) error

	// calls tracks calls to the methods.
	calls struct {
		// AddFollow holds details about calls to the AddFollow method.
		AddFollow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// UserId is the userId argument value.
			UserId model.UserID
			// FollweeUserId is the follweeUserId argument value.
			FollweeUserId model.UserID
		}
		// DeleteFollow holds details about calls to the DeleteFollow method.
		DeleteFollow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// UserId is the userId argument value.
			UserId model.UserID
			// FollweeUserId is the follweeUserId argument value.
			FollweeUserId model.UserID
		}
		// DeleteUserByUserName holds details about calls to the DeleteUserByUserName method.
		DeleteUserByUserName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// UserName is the userName argument value.
			UserName string
		}
		// GetFolloweesByUserId holds details about calls to the GetFolloweesByUserId method.
		GetFolloweesByUserId []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// SignedInUserId is the signedInUserId argument value.
			SignedInUserId model.UserID
		}
		// GetUserByUserId holds details about calls to the GetUserByUserId method.
		GetUserByUserId []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// ID is the id argument value.
			ID model.UserID
		}
		// GetUserByUserName holds details about calls to the GetUserByUserName method.
		GetUserByUserName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// UserName is the userName argument value.
			UserName string
		}
		// GetUserByUserNameWithFollowInfo holds details about calls to the GetUserByUserNameWithFollowInfo method.
		GetUserByUserNameWithFollowInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// UserName is the userName argument value.
			UserName string
			// SignedInUserId is the signedInUserId argument value.
			SignedInUserId model.UserID
		}
		// RegisterUser holds details about calls to the RegisterUser method.
		RegisterUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// U is the u argument value.
			U *model.User
		}
		// UpdateUser holds details about calls to the UpdateUser method.
		UpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// U is the u argument value.
			U *model.User
		}
		// UserExistsByUserName holds details about calls to the UserExistsByUserName method.
		UserExistsByUserName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
			// UserName is the userName argument value.
			UserName string
		}
		// WithTransaction holds details about calls to the WithTransaction method.
		WithTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Beginner
			// F is the f argument value.
			F func(tx *sqlx.Tx) error
		}
	}
	lockAddFollow                       sync.RWMutex
	lockDeleteFollow                    sync.RWMutex
	lockDeleteUserByUserName            sync.RWMutex
	lockGetFolloweesByUserId            sync.RWMutex
	lockGetUserByUserId                 sync.RWMutex
	lockGetUserByUserName               sync.RWMutex
	lockGetUserByUserNameWithFollowInfo sync.RWMutex
	lockRegisterUser                    sync.RWMutex
	lockUpdateUser                      sync.RWMutex
	lockUserExistsByUserName            sync.RWMutex
	lockWithTransaction                 sync.RWMutex
}

// AddFollow calls AddFollowFunc.
func (mock *UserRepositoryMock) AddFollow(ctx context.Context, db store.Execer, userId model.UserID, follweeUserId model.UserID) error {
	if mock.AddFollowFunc == nil {
		panic("UserRepositoryMock.AddFollowFunc: method is nil but UserRepository.AddFollow was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Db            store.Execer
		UserId        model.UserID
		FollweeUserId model.UserID
	}{
		Ctx:           ctx,
		Db:            db,
		UserId:        userId,
		FollweeUserId: follweeUserId,
	}
	mock.lockAddFollow.Lock()
	mock.calls.AddFollow = append(mock.calls.AddFollow, callInfo)
	mock.lockAddFollow.Unlock()
	return mock.AddFollowFunc(ctx, db, userId, follweeUserId)
}

// AddFollowCalls gets all the calls that were made to AddFollow.
// Check the length with:
//
//	len(mockedUserRepository.AddFollowCalls())
func (mock *UserRepositoryMock) AddFollowCalls() []struct {
	Ctx           context.Context
	Db            store.Execer
	UserId        model.UserID
	FollweeUserId model.UserID
} {
	var calls []struct {
		Ctx           context.Context
		Db            store.Execer
		UserId        model.UserID
		FollweeUserId model.UserID
	}
	mock.lockAddFollow.RLock()
	calls = mock.calls.AddFollow
	mock.lockAddFollow.RUnlock()
	return calls
}

// DeleteFollow calls DeleteFollowFunc.
func (mock *UserRepositoryMock) DeleteFollow(ctx context.Context, db store.Execer, userId model.UserID, follweeUserId model.UserID) error {
	if mock.DeleteFollowFunc == nil {
		panic("UserRepositoryMock.DeleteFollowFunc: method is nil but UserRepository.DeleteFollow was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Db            store.Execer
		UserId        model.UserID
		FollweeUserId model.UserID
	}{
		Ctx:           ctx,
		Db:            db,
		UserId:        userId,
		FollweeUserId: follweeUserId,
	}
	mock.lockDeleteFollow.Lock()
	mock.calls.DeleteFollow = append(mock.calls.DeleteFollow, callInfo)
	mock.lockDeleteFollow.Unlock()
	return mock.DeleteFollowFunc(ctx, db, userId, follweeUserId)
}

// DeleteFollowCalls gets all the calls that were made to DeleteFollow.
// Check the length with:
//
//	len(mockedUserRepository.DeleteFollowCalls())
func (mock *UserRepositoryMock) DeleteFollowCalls() []struct {
	Ctx           context.Context
	Db            store.Execer
	UserId        model.UserID
	FollweeUserId model.UserID
} {
	var calls []struct {
		Ctx           context.Context
		Db            store.Execer
		UserId        model.UserID
		FollweeUserId model.UserID
	}
	mock.lockDeleteFollow.RLock()
	calls = mock.calls.DeleteFollow
	mock.lockDeleteFollow.RUnlock()
	return calls
}

// DeleteUserByUserName calls DeleteUserByUserNameFunc.
func (mock *UserRepositoryMock) DeleteUserByUserName(ctx context.Context, db store.Execer, userName string) error {
	if mock.DeleteUserByUserNameFunc == nil {
		panic("UserRepositoryMock.DeleteUserByUserNameFunc: method is nil but UserRepository.DeleteUserByUserName was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       store.Execer
		UserName string
	}{
		Ctx:      ctx,
		Db:       db,
		UserName: userName,
	}
	mock.lockDeleteUserByUserName.Lock()
	mock.calls.DeleteUserByUserName = append(mock.calls.DeleteUserByUserName, callInfo)
	mock.lockDeleteUserByUserName.Unlock()
	return mock.DeleteUserByUserNameFunc(ctx, db, userName)
}

// DeleteUserByUserNameCalls gets all the calls that were made to DeleteUserByUserName.
// Check the length with:
//
//	len(mockedUserRepository.DeleteUserByUserNameCalls())
func (mock *UserRepositoryMock) DeleteUserByUserNameCalls() []struct {
	Ctx      context.Context
	Db       store.Execer
	UserName string
} {
	var calls []struct {
		Ctx      context.Context
		Db       store.Execer
		UserName string
	}
	mock.lockDeleteUserByUserName.RLock()
	calls = mock.calls.DeleteUserByUserName
	mock.lockDeleteUserByUserName.RUnlock()
	return calls
}

// GetFolloweesByUserId calls GetFolloweesByUserIdFunc.
func (mock *UserRepositoryMock) GetFolloweesByUserId(ctx context.Context, db store.Queryer, signedInUserId model.UserID) ([]*model.User, error) {
	if mock.GetFolloweesByUserIdFunc == nil {
		panic("UserRepositoryMock.GetFolloweesByUserIdFunc: method is nil but UserRepository.GetFolloweesByUserId was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Db             store.Queryer
		SignedInUserId model.UserID
	}{
		Ctx:            ctx,
		Db:             db,
		SignedInUserId: signedInUserId,
	}
	mock.lockGetFolloweesByUserId.Lock()
	mock.calls.GetFolloweesByUserId = append(mock.calls.GetFolloweesByUserId, callInfo)
	mock.lockGetFolloweesByUserId.Unlock()
	return mock.GetFolloweesByUserIdFunc(ctx, db, signedInUserId)
}

// GetFolloweesByUserIdCalls gets all the calls that were made to GetFolloweesByUserId.
// Check the length with:
//
//	len(mockedUserRepository.GetFolloweesByUserIdCalls())
func (mock *UserRepositoryMock) GetFolloweesByUserIdCalls() []struct {
	Ctx            context.Context
	Db             store.Queryer
	SignedInUserId model.UserID
} {
	var calls []struct {
		Ctx            context.Context
		Db             store.Queryer
		SignedInUserId model.UserID
	}
	mock.lockGetFolloweesByUserId.RLock()
	calls = mock.calls.GetFolloweesByUserId
	mock.lockGetFolloweesByUserId.RUnlock()
	return calls
}

// GetUserByUserId calls GetUserByUserIdFunc.
func (mock *UserRepositoryMock) GetUserByUserId(ctx context.Context, db store.Queryer, id model.UserID) (*model.User, error) {
	if mock.GetUserByUserIdFunc == nil {
		panic("UserRepositoryMock.GetUserByUserIdFunc: method is nil but UserRepository.GetUserByUserId was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Queryer
		ID  model.UserID
	}{
		Ctx: ctx,
		Db:  db,
		ID:  id,
	}
	mock.lockGetUserByUserId.Lock()
	mock.calls.GetUserByUserId = append(mock.calls.GetUserByUserId, callInfo)
	mock.lockGetUserByUserId.Unlock()
	return mock.GetUserByUserIdFunc(ctx, db, id)
}

// GetUserByUserIdCalls gets all the calls that were made to GetUserByUserId.
// Check the length with:
//
//	len(mockedUserRepository.GetUserByUserIdCalls())
func (mock *UserRepositoryMock) GetUserByUserIdCalls() []struct {
	Ctx context.Context
	Db  store.Queryer
	ID  model.UserID
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Queryer
		ID  model.UserID
	}
	mock.lockGetUserByUserId.RLock()
	calls = mock.calls.GetUserByUserId
	mock.lockGetUserByUserId.RUnlock()
	return calls
}

// GetUserByUserName calls GetUserByUserNameFunc.
func (mock *UserRepositoryMock) GetUserByUserName(ctx context.Context, db store.Queryer, userName string) (*model.User, error) {
	if mock.GetUserByUserNameFunc == nil {
		panic("UserRepositoryMock.GetUserByUserNameFunc: method is nil but UserRepository.GetUserByUserName was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       store.Queryer
		UserName string
	}{
		Ctx:      ctx,
		Db:       db,
		UserName: userName,
	}
	mock.lockGetUserByUserName.Lock()
	mock.calls.GetUserByUserName = append(mock.calls.GetUserByUserName, callInfo)
	mock.lockGetUserByUserName.Unlock()
	return mock.GetUserByUserNameFunc(ctx, db, userName)
}

// GetUserByUserNameCalls gets all the calls that were made to GetUserByUserName.
// Check the length with:
//
//	len(mockedUserRepository.GetUserByUserNameCalls())
func (mock *UserRepositoryMock) GetUserByUserNameCalls() []struct {
	Ctx      context.Context
	Db       store.Queryer
	UserName string
} {
	var calls []struct {
		Ctx      context.Context
		Db       store.Queryer
		UserName string
	}
	mock.lockGetUserByUserName.RLock()
	calls = mock.calls.GetUserByUserName
	mock.lockGetUserByUserName.RUnlock()
	return calls
}

// GetUserByUserNameWithFollowInfo calls GetUserByUserNameWithFollowInfoFunc.
func (mock *UserRepositoryMock) GetUserByUserNameWithFollowInfo(ctx context.Context, db store.Queryer, userName string, signedInUserId model.UserID) (*model.User, error) {
	if mock.GetUserByUserNameWithFollowInfoFunc == nil {
		panic("UserRepositoryMock.GetUserByUserNameWithFollowInfoFunc: method is nil but UserRepository.GetUserByUserNameWithFollowInfo was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Db             store.Queryer
		UserName       string
		SignedInUserId model.UserID
	}{
		Ctx:            ctx,
		Db:             db,
		UserName:       userName,
		SignedInUserId: signedInUserId,
	}
	mock.lockGetUserByUserNameWithFollowInfo.Lock()
	mock.calls.GetUserByUserNameWithFollowInfo = append(mock.calls.GetUserByUserNameWithFollowInfo, callInfo)
	mock.lockGetUserByUserNameWithFollowInfo.Unlock()
	return mock.GetUserByUserNameWithFollowInfoFunc(ctx, db, userName, signedInUserId)
}

// GetUserByUserNameWithFollowInfoCalls gets all the calls that were made to GetUserByUserNameWithFollowInfo.
// Check the length with:
//
//	len(mockedUserRepository.GetUserByUserNameWithFollowInfoCalls())
func (mock *UserRepositoryMock) GetUserByUserNameWithFollowInfoCalls() []struct {
	Ctx            context.Context
	Db             store.Queryer
	UserName       string
	SignedInUserId model.UserID
} {
	var calls []struct {
		Ctx            context.Context
		Db             store.Queryer
		UserName       string
		SignedInUserId model.UserID
	}
	mock.lockGetUserByUserNameWithFollowInfo.RLock()
	calls = mock.calls.GetUserByUserNameWithFollowInfo
	mock.lockGetUserByUserNameWithFollowInfo.RUnlock()
	return calls
}

// RegisterUser calls RegisterUserFunc.
func (mock *UserRepositoryMock) RegisterUser(ctx context.Context, db store.Execer, u *model.User) error {
	if mock.RegisterUserFunc == nil {
		panic("UserRepositoryMock.RegisterUserFunc: method is nil but UserRepository.RegisterUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Execer
		U   *model.User
	}{
		Ctx: ctx,
		Db:  db,
		U:   u,
	}
	mock.lockRegisterUser.Lock()
	mock.calls.RegisterUser = append(mock.calls.RegisterUser, callInfo)
	mock.lockRegisterUser.Unlock()
	return mock.RegisterUserFunc(ctx, db, u)
}

// RegisterUserCalls gets all the calls that were made to RegisterUser.
// Check the length with:
//
//	len(mockedUserRepository.RegisterUserCalls())
func (mock *UserRepositoryMock) RegisterUserCalls() []struct {
	Ctx context.Context
	Db  store.Execer
	U   *model.User
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Execer
		U   *model.User
	}
	mock.lockRegisterUser.RLock()
	calls = mock.calls.RegisterUser
	mock.lockRegisterUser.RUnlock()
	return calls
}

// UpdateUser calls UpdateUserFunc.
func (mock *UserRepositoryMock) UpdateUser(ctx context.Context, db store.Execer, u *model.User) error {
	if mock.UpdateUserFunc == nil {
		panic("UserRepositoryMock.UpdateUserFunc: method is nil but UserRepository.UpdateUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Execer
		U   *model.User
	}{
		Ctx: ctx,
		Db:  db,
		U:   u,
	}
	mock.lockUpdateUser.Lock()
	mock.calls.UpdateUser = append(mock.calls.UpdateUser, callInfo)
	mock.lockUpdateUser.Unlock()
	return mock.UpdateUserFunc(ctx, db, u)
}

// UpdateUserCalls gets all the calls that were made to UpdateUser.
// Check the length with:
//
//	len(mockedUserRepository.UpdateUserCalls())
func (mock *UserRepositoryMock) UpdateUserCalls() []struct {
	Ctx context.Context
	Db  store.Execer
	U   *model.User
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Execer
		U   *model.User
	}
	mock.lockUpdateUser.RLock()
	calls = mock.calls.UpdateUser
	mock.lockUpdateUser.RUnlock()
	return calls
}

// UserExistsByUserName calls UserExistsByUserNameFunc.
func (mock *UserRepositoryMock) UserExistsByUserName(ctx context.Context, db store.Queryer, userName string) (bool, error) {
	if mock.UserExistsByUserNameFunc == nil {
		panic("UserRepositoryMock.UserExistsByUserNameFunc: method is nil but UserRepository.UserExistsByUserName was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       store.Queryer
		UserName string
	}{
		Ctx:      ctx,
		Db:       db,
		UserName: userName,
	}
	mock.lockUserExistsByUserName.Lock()
	mock.calls.UserExistsByUserName = append(mock.calls.UserExistsByUserName, callInfo)
	mock.lockUserExistsByUserName.Unlock()
	return mock.UserExistsByUserNameFunc(ctx, db, userName)
}

// UserExistsByUserNameCalls gets all the calls that were made to UserExistsByUserName.
// Check the length with:
//
//	len(mockedUserRepository.UserExistsByUserNameCalls())
func (mock *UserRepositoryMock) UserExistsByUserNameCalls() []struct {
	Ctx      context.Context
	Db       store.Queryer
	UserName string
} {
	var calls []struct {
		Ctx      context.Context
		Db       store.Queryer
		UserName string
	}
	mock.lockUserExistsByUserName.RLock()
	calls = mock.calls.UserExistsByUserName
	mock.lockUserExistsByUserName.RUnlock()
	return calls
}

// WithTransaction calls WithTransactionFunc.
func (mock *UserRepositoryMock) WithTransaction(ctx context.Context, db store.Beginner, f func(tx *sqlx.Tx) error) error {
	if mock.WithTransactionFunc == nil {
		panic("UserRepositoryMock.WithTransactionFunc: method is nil but UserRepository.WithTransaction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Beginner
		F   func(tx *sqlx.Tx) error
	}{
		Ctx: ctx,
		Db:  db,
		F:   f,
	}
	mock.lockWithTransaction.Lock()
	mock.calls.WithTransaction = append(mock.calls.WithTransaction, callInfo)
	mock.lockWithTransaction.Unlock()
	return mock.WithTransactionFunc(ctx, db, f)
}

// WithTransactionCalls gets all the calls that were made to WithTransaction.
// Check the length with:
//
//	len(mockedUserRepository.WithTransactionCalls())
func (mock *UserRepositoryMock) WithTransactionCalls() []struct {
	Ctx context.Context
	Db  store.Beginner
	F   func(tx *sqlx.Tx) error
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Beginner
		F   func(tx *sqlx.Tx) error
	}
	mock.lockWithTransaction.RLock()
	calls = mock.calls.WithTransaction
	mock.lockWithTransaction.RUnlock()
	return calls
}

// Ensure, that AuthMock does implement Auth.
// If this is not the case, regenerate this file with moq.
var _ Auth = &AuthMock{}

// AuthMock is a mock implementation of Auth.
//
//	func TestSomethingThatUsesAuth(t *testing.T) {
//
//		// make and configure a mocked Auth
//		mockedAuth := &AuthMock{
//			ConfirmSignUpFunc: func(ctx context.Context, userId model.UserID, code string) error {
//				panic("mock out the ConfirmSignUp method")
//			},
//			RefreshTokenFunc: func(ctx context.Context, userIdentifier string, refreshToken string) (*model.Tokens, error) {
//				panic("mock out the RefreshToken method")
//			},
//			SignInFunc: func(ctx context.Context, userIdentifier string, password string) (*model.Tokens, error) {
//				panic("mock out the SignIn method")
//			},
//			SignUpFunc: func(ctx context.Context, userId model.UserID, email string, password string) error {
//				panic("mock out the SignUp method")
//			},
//		}
//
//		// use mockedAuth in code that requires Auth
//		// and then make assertions.
//
//	}
type AuthMock struct {
	// ConfirmSignUpFunc mocks the ConfirmSignUp method.
	ConfirmSignUpFunc func(ctx context.Context, userId model.UserID, code string) error

	// RefreshTokenFunc mocks the RefreshToken method.
	RefreshTokenFunc func(ctx context.Context, userIdentifier string, refreshToken string) (*model.Tokens, error)

	// SignInFunc mocks the SignIn method.
	SignInFunc func(ctx context.Context, userIdentifier string, password string) (*model.Tokens, error)

	// SignUpFunc mocks the SignUp method.
	SignUpFunc func(ctx context.Context, userId model.UserID, email string, password string) error

	// calls tracks calls to the methods.
	calls struct {
		// ConfirmSignUp holds details about calls to the ConfirmSignUp method.
		ConfirmSignUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserId is the userId argument value.
			UserId model.UserID
			// Code is the code argument value.
			Code string
		}
		// RefreshToken holds details about calls to the RefreshToken method.
		RefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserIdentifier is the userIdentifier argument value.
			UserIdentifier string
			// RefreshToken is the refreshToken argument value.
			RefreshToken string
		}
		// SignIn holds details about calls to the SignIn method.
		SignIn []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserIdentifier is the userIdentifier argument value.
			UserIdentifier string
			// Password is the password argument value.
			Password string
		}
		// SignUp holds details about calls to the SignUp method.
		SignUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserId is the userId argument value.
			UserId model.UserID
			// Email is the email argument value.
			Email string
			// Password is the password argument value.
			Password string
		}
	}
	lockConfirmSignUp sync.RWMutex
	lockRefreshToken  sync.RWMutex
	lockSignIn        sync.RWMutex
	lockSignUp        sync.RWMutex
}

// ConfirmSignUp calls ConfirmSignUpFunc.
func (mock *AuthMock) ConfirmSignUp(ctx context.Context, userId model.UserID, code string) error {
	if mock.ConfirmSignUpFunc == nil {
		panic("AuthMock.ConfirmSignUpFunc: method is nil but Auth.ConfirmSignUp was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserId model.UserID
		Code   string
	}{
		Ctx:    ctx,
		UserId: userId,
		Code:   code,
	}
	mock.lockConfirmSignUp.Lock()
	mock.calls.ConfirmSignUp = append(mock.calls.ConfirmSignUp, callInfo)
	mock.lockConfirmSignUp.Unlock()
	return mock.ConfirmSignUpFunc(ctx, userId, code)
}

// ConfirmSignUpCalls gets all the calls that were made to ConfirmSignUp.
// Check the length with:
//
//	len(mockedAuth.ConfirmSignUpCalls())
func (mock *AuthMock) ConfirmSignUpCalls() []struct {
	Ctx    context.Context
	UserId model.UserID
	Code   string
} {
	var calls []struct {
		Ctx    context.Context
		UserId model.UserID
		Code   string
	}
	mock.lockConfirmSignUp.RLock()
	calls = mock.calls.ConfirmSignUp
	mock.lockConfirmSignUp.RUnlock()
	return calls
}

// RefreshToken calls RefreshTokenFunc.
func (mock *AuthMock) RefreshToken(ctx context.Context, userIdentifier string, refreshToken string) (*model.Tokens, error) {
	if mock.RefreshTokenFunc == nil {
		panic("AuthMock.RefreshTokenFunc: method is nil but Auth.RefreshToken was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		UserIdentifier string
		RefreshToken   string
	}{
		Ctx:            ctx,
		UserIdentifier: userIdentifier,
		RefreshToken:   refreshToken,
	}
	mock.lockRefreshToken.Lock()
	mock.calls.RefreshToken = append(mock.calls.RefreshToken, callInfo)
	mock.lockRefreshToken.Unlock()
	return mock.RefreshTokenFunc(ctx, userIdentifier, refreshToken)
}

// RefreshTokenCalls gets all the calls that were made to RefreshToken.
// Check the length with:
//
//	len(mockedAuth.RefreshTokenCalls())
func (mock *AuthMock) RefreshTokenCalls() []struct {
	Ctx            context.Context
	UserIdentifier string
	RefreshToken   string
} {
	var calls []struct {
		Ctx            context.Context
		UserIdentifier string
		RefreshToken   string
	}
	mock.lockRefreshToken.RLock()
	calls = mock.calls.RefreshToken
	mock.lockRefreshToken.RUnlock()
	return calls
}

// SignIn calls SignInFunc.
func (mock *AuthMock) SignIn(ctx context.Context, userIdentifier string, password string) (*model.Tokens, error) {
	if mock.SignInFunc == nil {
		panic("AuthMock.SignInFunc: method is nil but Auth.SignIn was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		UserIdentifier string
		Password       string
	}{
		Ctx:            ctx,
		UserIdentifier: userIdentifier,
		Password:       password,
	}
	mock.lockSignIn.Lock()
	mock.calls.SignIn = append(mock.calls.SignIn, callInfo)
	mock.lockSignIn.Unlock()
	return mock.SignInFunc(ctx, userIdentifier, password)
}

// SignInCalls gets all the calls that were made to SignIn.
// Check the length with:
//
//	len(mockedAuth.SignInCalls())
func (mock *AuthMock) SignInCalls() []struct {
	Ctx            context.Context
	UserIdentifier string
	Password       string
} {
	var calls []struct {
		Ctx            context.Context
		UserIdentifier string
		Password       string
	}
	mock.lockSignIn.RLock()
	calls = mock.calls.SignIn
	mock.lockSignIn.RUnlock()
	return calls
}

// SignUp calls SignUpFunc.
func (mock *AuthMock) SignUp(ctx context.Context, userId model.UserID, email string, password string) error {
	if mock.SignUpFunc == nil {
		panic("AuthMock.SignUpFunc: method is nil but Auth.SignUp was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		UserId   model.UserID
		Email    string
		Password string
	}{
		Ctx:      ctx,
		UserId:   userId,
		Email:    email,
		Password: password,
	}
	mock.lockSignUp.Lock()
	mock.calls.SignUp = append(mock.calls.SignUp, callInfo)
	mock.lockSignUp.Unlock()
	return mock.SignUpFunc(ctx, userId, email, password)
}

// SignUpCalls gets all the calls that were made to SignUp.
// Check the length with:
//
//	len(mockedAuth.SignUpCalls())
func (mock *AuthMock) SignUpCalls() []struct {
	Ctx      context.Context
	UserId   model.UserID
	Email    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		UserId   model.UserID
		Email    string
		Password string
	}
	mock.lockSignUp.RLock()
	calls = mock.calls.SignUp
	mock.lockSignUp.RUnlock()
	return calls
}
